// tslint:disable
/**
 * OrgBook BC API
 * OrgBook BC is a public, searchable directory of digital records for registered businesses in the Province of British Columbia. Over time, other government organizations and businesses will also begin to issue digital records through OrgBook BC. For example, permits and licenses issued by various government services.
 *
 * The version of the OpenAPI document: v2
 * Contact: bcdevexchange@gov.bc.ca
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Credential
 */
export interface Credential {
    /**
     * 
     * @type {number}
     * @memberof Credential
     */
    topic?: number;
    /**
     * 
     * @type {number}
     * @memberof Credential
     */
    credential_set?: number;
    /**
     * 
     * @type {number}
     * @memberof Credential
     */
    credential_type?: number;
    /**
     * 
     * @type {number}
     * @memberof Credential
     */
    credential_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    credential_def_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    cardinality_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    effective_date?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Credential
     */
    inactive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Credential
     */
    latest?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Credential
     */
    revoked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    revoked_date?: string;
    /**
     * 
     * @type {number}
     * @memberof Credential
     */
    revoked_by?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Credential
     */
    related_topics?: Array<number>;
    /**
     * 
     * @type {Array<CredentialAttribute>}
     * @memberof Credential
     */
    attributes: Array<CredentialAttribute>;
}
/**
 * 
 * @export
 * @interface CredentialAddress
 */
export interface CredentialAddress {
    /**
     * 
     * @type {string}
     * @memberof CredentialAddress
     */
    province?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialAddress
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialAddress
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialAddress
     */
    update_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialAddress
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialAddress
     */
    addressee?: string;
    /**
     * 
     * @type {number}
     * @memberof CredentialAddress
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialAddress
     */
    civic_address?: string;
    /**
     * 
     * @type {number}
     * @memberof CredentialAddress
     */
    credential_id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialAddress
     */
    postal_code?: string;
}
/**
 * 
 * @export
 * @interface CredentialAttribute
 */
export interface CredentialAttribute {
    /**
     * 
     * @type {number}
     * @memberof CredentialAttribute
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialAttribute
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialAttribute
     */
    format?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialAttribute
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof CredentialAttribute
     */
    credential_id?: number;
}
/**
 * 
 * @export
 * @interface CredentialAutocomplete
 */
export interface CredentialAutocomplete {
    /**
     * 
     * @type {number}
     * @memberof CredentialAutocomplete
     */
    id?: number;
    /**
     * 
     * @type {Array<CredentialName>}
     * @memberof CredentialAutocomplete
     */
    names: Array<CredentialName>;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialAutocomplete
     */
    inactive?: boolean;
}
/**
 * 
 * @export
 * @interface CredentialExt
 */
export interface CredentialExt {
    /**
     * 
     * @type {number}
     * @memberof CredentialExt
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialExt
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialExt
     */
    effective_date?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialExt
     */
    inactive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialExt
     */
    latest?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialExt
     */
    revoked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CredentialExt
     */
    revoked_date?: string;
    /**
     * 
     * @type {number}
     * @memberof CredentialExt
     */
    credential_id?: number;
    /**
     * 
     * @type {CredentialType}
     * @memberof CredentialExt
     */
    credential_type: CredentialType;
    /**
     * 
     * @type {Array<CredentialAddress>}
     * @memberof CredentialExt
     */
    addresses: Array<CredentialAddress>;
    /**
     * 
     * @type {Array<CredentialAttribute>}
     * @memberof CredentialExt
     */
    attributes: Array<CredentialAttribute>;
    /**
     * 
     * @type {Array<CredentialName>}
     * @memberof CredentialExt
     */
    names: Array<CredentialName>;
    /**
     * 
     * @type {CredentialName}
     * @memberof CredentialExt
     */
    local_name: CredentialName;
    /**
     * 
     * @type {CredentialName}
     * @memberof CredentialExt
     */
    remote_name: CredentialName;
    /**
     * 
     * @type {CredentialTopicExt}
     * @memberof CredentialExt
     */
    topic: CredentialTopicExt;
    /**
     * 
     * @type {Array<CredentialNamedTopic>}
     * @memberof CredentialExt
     */
    related_topics: Array<CredentialNamedTopic>;
}
/**
 * 
 * @export
 * @interface CredentialName
 */
export interface CredentialName {
    /**
     * 
     * @type {number}
     * @memberof CredentialName
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialName
     */
    text?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialName
     */
    language?: string;
    /**
     * 
     * @type {number}
     * @memberof CredentialName
     */
    credential_id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialName
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface CredentialNamedTopic
 */
export interface CredentialNamedTopic {
    /**
     * 
     * @type {number}
     * @memberof CredentialNamedTopic
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialNamedTopic
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialNamedTopic
     */
    update_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialNamedTopic
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialNamedTopic
     */
    type?: string;
    /**
     * 
     * @type {Array<CredentialName>}
     * @memberof CredentialNamedTopic
     */
    names: Array<CredentialName>;
    /**
     * 
     * @type {CredentialName}
     * @memberof CredentialNamedTopic
     */
    local_name: CredentialName;
    /**
     * 
     * @type {CredentialName}
     * @memberof CredentialNamedTopic
     */
    remote_name: CredentialName;
}
/**
 * 
 * @export
 * @interface CredentialSearch
 */
export interface CredentialSearch {
    /**
     * 
     * @type {number}
     * @memberof CredentialSearch
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialSearch
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialSearch
     */
    update_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialSearch
     */
    effective_date?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialSearch
     */
    inactive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialSearch
     */
    latest?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialSearch
     */
    revoked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CredentialSearch
     */
    revoked_date?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialSearch
     */
    credential_id?: string;
    /**
     * 
     * @type {CredentialSet}
     * @memberof CredentialSearch
     */
    credential_set: CredentialSet;
    /**
     * 
     * @type {CredentialType}
     * @memberof CredentialSearch
     */
    credential_type: CredentialType;
    /**
     * 
     * @type {Array<CredentialAddress>}
     * @memberof CredentialSearch
     */
    addresses: Array<CredentialAddress>;
    /**
     * 
     * @type {Array<CredentialAttribute>}
     * @memberof CredentialSearch
     */
    attributes: Array<CredentialAttribute>;
    /**
     * 
     * @type {Array<CredentialName>}
     * @memberof CredentialSearch
     */
    names: Array<CredentialName>;
    /**
     * 
     * @type {CredentialNamedTopic}
     * @memberof CredentialSearch
     */
    topic: CredentialNamedTopic;
    /**
     * 
     * @type {Array<CredentialNamedTopic>}
     * @memberof CredentialSearch
     */
    related_topics: Array<CredentialNamedTopic>;
}
/**
 * 
 * @export
 * @interface CredentialSet
 */
export interface CredentialSet {
    /**
     * 
     * @type {number}
     * @memberof CredentialSet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialSet
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialSet
     */
    update_timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof CredentialSet
     */
    latest_credential_id?: number;
    /**
     * 
     * @type {number}
     * @memberof CredentialSet
     */
    topic_id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialSet
     */
    first_effective_date?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialSet
     */
    last_effective_date?: string;
}
/**
 * 
 * @export
 * @interface CredentialTopicExt
 */
export interface CredentialTopicExt {
    /**
     * 
     * @type {number}
     * @memberof CredentialTopicExt
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialTopicExt
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialTopicExt
     */
    update_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialTopicExt
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialTopicExt
     */
    type?: string;
    /**
     * 
     * @type {Array<CredentialName>}
     * @memberof CredentialTopicExt
     */
    names: Array<CredentialName>;
    /**
     * 
     * @type {CredentialName}
     * @memberof CredentialTopicExt
     */
    local_name: CredentialName;
    /**
     * 
     * @type {CredentialName}
     * @memberof CredentialTopicExt
     */
    remote_name: CredentialName;
    /**
     * 
     * @type {Array<CredentialAddress>}
     * @memberof CredentialTopicExt
     */
    addresses: Array<CredentialAddress>;
    /**
     * 
     * @type {Array<TopicAttribute>}
     * @memberof CredentialTopicExt
     */
    attributes: Array<TopicAttribute>;
}
/**
 * 
 * @export
 * @interface CredentialTopicSearch
 */
export interface CredentialTopicSearch {
    /**
     * 
     * @type {number}
     * @memberof CredentialTopicSearch
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialTopicSearch
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialTopicSearch
     */
    update_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialTopicSearch
     */
    effective_date?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialTopicSearch
     */
    inactive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialTopicSearch
     */
    latest?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialTopicSearch
     */
    revoked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CredentialTopicSearch
     */
    revoked_date?: string;
    /**
     * 
     * @type {number}
     * @memberof CredentialTopicSearch
     */
    credential_id?: number;
    /**
     * 
     * @type {CredentialSet}
     * @memberof CredentialTopicSearch
     */
    credential_set: CredentialSet;
    /**
     * 
     * @type {CredentialType}
     * @memberof CredentialTopicSearch
     */
    credential_type: CredentialType;
    /**
     * 
     * @type {Array<CredentialAttribute>}
     * @memberof CredentialTopicSearch
     */
    attributes: Array<CredentialAttribute>;
    /**
     * 
     * @type {Array<CredentialName>}
     * @memberof CredentialTopicSearch
     */
    names: Array<CredentialName>;
    /**
     * 
     * @type {CredentialTopicExt}
     * @memberof CredentialTopicSearch
     */
    topic: CredentialTopicExt;
    /**
     * 
     * @type {Array<CredentialNamedTopic>}
     * @memberof CredentialTopicSearch
     */
    related_topics: Array<CredentialNamedTopic>;
}
/**
 * 
 * @export
 * @interface CredentialType
 */
export interface CredentialType {
    /**
     * 
     * @type {number}
     * @memberof CredentialType
     */
    id?: number;
    /**
     * 
     * @type {Issuer}
     * @memberof CredentialType
     */
    issuer: Issuer;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialType
     */
    has_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CredentialType
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialType
     */
    update_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialType
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CredentialType
     */
    credential_def_id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CredentialType
     */
    last_issue_date?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CredentialType
     */
    url?: string | null;
    /**
     * 
     * @type {CredentialTypeSchema}
     * @memberof CredentialType
     */
    schema?: CredentialTypeSchema;
}
/**
 * 
 * @export
 * @interface CredentialTypeSchema
 */
export interface CredentialTypeSchema {
    /**
     * 
     * @type {number}
     * @memberof CredentialTypeSchema
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialTypeSchema
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialTypeSchema
     */
    update_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialTypeSchema
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialTypeSchema
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialTypeSchema
     */
    origin_did: string;
}
/**
 * 
 * @export
 * @interface CustomTopic
 */
export interface CustomTopic {
    /**
     * 
     * @type {number}
     * @memberof CustomTopic
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomTopic
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTopic
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTopic
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTopic
     */
    names?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTopic
     */
    addresses?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTopic
     */
    attributes?: string;
}
/**
 * 
 * @export
 * @interface ExpandedCredential
 */
export interface ExpandedCredential {
    /**
     * 
     * @type {number}
     * @memberof ExpandedCredential
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedCredential
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedCredential
     */
    effective_date?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExpandedCredential
     */
    inactive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpandedCredential
     */
    latest?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExpandedCredential
     */
    revoked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExpandedCredential
     */
    revoked_date?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedCredential
     */
    credential_id?: number;
    /**
     * 
     * @type {CredentialType}
     * @memberof ExpandedCredential
     */
    credential_type: CredentialType;
    /**
     * 
     * @type {Array<CredentialAddress>}
     * @memberof ExpandedCredential
     */
    addresses: Array<CredentialAddress>;
    /**
     * 
     * @type {Array<CredentialAttribute>}
     * @memberof ExpandedCredential
     */
    attributes: Array<CredentialAttribute>;
    /**
     * 
     * @type {Array<CredentialName>}
     * @memberof ExpandedCredential
     */
    names: Array<CredentialName>;
    /**
     * 
     * @type {CredentialName}
     * @memberof ExpandedCredential
     */
    local_name: CredentialName;
    /**
     * 
     * @type {CredentialName}
     * @memberof ExpandedCredential
     */
    remote_name: CredentialName;
    /**
     * 
     * @type {CredentialTopicExt}
     * @memberof ExpandedCredential
     */
    topic: CredentialTopicExt;
    /**
     * 
     * @type {Array<CredentialNamedTopic>}
     * @memberof ExpandedCredential
     */
    related_topics: Array<CredentialNamedTopic>;
    /**
     * 
     * @type {ExpandedCredentialSet}
     * @memberof ExpandedCredential
     */
    credential_set: ExpandedCredentialSet;
}
/**
 * 
 * @export
 * @interface ExpandedCredentialSet
 */
export interface ExpandedCredentialSet {
    /**
     * 
     * @type {number}
     * @memberof ExpandedCredentialSet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedCredentialSet
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedCredentialSet
     */
    update_timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpandedCredentialSet
     */
    latest_credential_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedCredentialSet
     */
    topic_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpandedCredentialSet
     */
    first_effective_date?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpandedCredentialSet
     */
    last_effective_date?: string;
    /**
     * 
     * @type {Array<CredentialExt>}
     * @memberof ExpandedCredentialSet
     */
    credentials: Array<CredentialExt>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    page_size?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    first_index?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    last_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Credential>}
     * @memberof InlineResponse200
     */
    results: Array<Credential>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    page_size?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    first_index?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    last_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CredentialType>}
     * @memberof InlineResponse2001
     */
    results: Array<CredentialType>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    page_size?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    first_index?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    last_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Issuer>}
     * @memberof InlineResponse2002
     */
    results: Array<Issuer>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    page_size?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    first_index?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    last_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Schema>}
     * @memberof InlineResponse2003
     */
    results: Array<Schema>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    page_size?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    first_index?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    last_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CredentialAutocomplete>}
     * @memberof InlineResponse2004
     */
    results: Array<CredentialAutocomplete>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    page_size?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    first_index?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    last_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CredentialSearch>}
     * @memberof InlineResponse2005
     */
    results: Array<CredentialSearch>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    page_size?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    first_index?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    last_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CredentialTopicSearch>}
     * @memberof InlineResponse2006
     */
    results: Array<CredentialTopicSearch>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    page_size?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    first_index?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    last_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Topic>}
     * @memberof InlineResponse2007
     */
    results: Array<Topic>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008
     */
    page_size?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008
     */
    first_index?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008
     */
    last_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<TopicRelationship>}
     * @memberof InlineResponse2008
     */
    results: Array<TopicRelationship>;
}
/**
 * 
 * @export
 * @interface Issuer
 */
export interface Issuer {
    /**
     * 
     * @type {number}
     * @memberof Issuer
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Issuer
     */
    has_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    update_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    did: string;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    abbreviation: string;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    endpoint?: string | null;
}
/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    update_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    origin_did: string;
}
/**
 * 
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * 
     * @type {number}
     * @memberof Topic
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    create_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    update_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    type?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Topic
     */
    related_to?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Topic
     */
    related_from?: Array<number>;
}
/**
 * 
 * @export
 * @interface TopicAttribute
 */
export interface TopicAttribute {
    /**
     * 
     * @type {number}
     * @memberof TopicAttribute
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TopicAttribute
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof TopicAttribute
     */
    format?: string;
    /**
     * 
     * @type {string}
     * @memberof TopicAttribute
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof TopicAttribute
     */
    credential_id?: number;
    /**
     * 
     * @type {string}
     * @memberof TopicAttribute
     */
    credential_type_id?: string;
}
/**
 * 
 * @export
 * @interface TopicRelationship
 */
export interface TopicRelationship {
    /**
     * 
     * @type {number}
     * @memberof TopicRelationship
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TopicRelationship
     */
    credential?: number;
    /**
     * 
     * @type {number}
     * @memberof TopicRelationship
     */
    topic?: number;
    /**
     * 
     * @type {number}
     * @memberof TopicRelationship
     */
    related_topic?: number;
}

/**
 * CredentialApi - axios parameter creator
 * @export
 */
export const CredentialApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialGetLatest: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling credentialGetLatest.');
            }
            const localVarPath = `/credential/{id}/latest`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/credential`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling credentialRead.');
            }
            const localVarPath = `/credential/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialRetrieveFormatted: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling credentialRetrieveFormatted.');
            }
            const localVarPath = `/credential/{id}/formatted`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialVerify: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling credentialVerify.');
            }
            const localVarPath = `/credential/{id}/verify`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialApi - functional programming interface
 * @export
 */
export const CredentialApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialGetLatest(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credential>> {
            const localVarAxiosArgs = await CredentialApiAxiosParamCreator(configuration).credentialGetLatest(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await CredentialApiAxiosParamCreator(configuration).credentialList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credential>> {
            const localVarAxiosArgs = await CredentialApiAxiosParamCreator(configuration).credentialRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialRetrieveFormatted(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credential>> {
            const localVarAxiosArgs = await CredentialApiAxiosParamCreator(configuration).credentialRetrieveFormatted(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialVerify(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credential>> {
            const localVarAxiosArgs = await CredentialApiAxiosParamCreator(configuration).credentialVerify(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CredentialApi - factory interface
 * @export
 */
export const CredentialApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialGetLatest(id: number, options?: any): AxiosPromise<Credential> {
            return CredentialApiFp(configuration).credentialGetLatest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialList(options?: any): AxiosPromise<InlineResponse200> {
            return CredentialApiFp(configuration).credentialList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialRead(id: number, options?: any): AxiosPromise<Credential> {
            return CredentialApiFp(configuration).credentialRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialRetrieveFormatted(id: number, options?: any): AxiosPromise<Credential> {
            return CredentialApiFp(configuration).credentialRetrieveFormatted(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialVerify(id: number, options?: any): AxiosPromise<Credential> {
            return CredentialApiFp(configuration).credentialVerify(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialApi - object-oriented interface
 * @export
 * @class CredentialApi
 * @extends {BaseAPI}
 */
export class CredentialApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public credentialGetLatest(id: number, options?: any) {
        return CredentialApiFp(this.configuration).credentialGetLatest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public credentialList(options?: any) {
        return CredentialApiFp(this.configuration).credentialList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public credentialRead(id: number, options?: any) {
        return CredentialApiFp(this.configuration).credentialRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public credentialRetrieveFormatted(id: number, options?: any) {
        return CredentialApiFp(this.configuration).credentialRetrieveFormatted(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public credentialVerify(id: number, options?: any) {
        return CredentialApiFp(this.configuration).credentialVerify(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CredentialtypeApi - axios parameter creator
 * @export
 */
export const CredentialtypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this credential type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialtypeFetchLanguage: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling credentialtypeFetchLanguage.');
            }
            const localVarPath = `/credentialtype/{id}/language`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialtypeFetchLogo: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling credentialtypeFetchLogo.');
            }
            const localVarPath = `/credentialtype/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialtypeList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/credentialtype`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialtypeRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling credentialtypeRead.');
            }
            const localVarPath = `/credentialtype/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialtypeApi - functional programming interface
 * @export
 */
export const CredentialtypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this credential type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialtypeFetchLanguage(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialType>> {
            const localVarAxiosArgs = await CredentialtypeApiAxiosParamCreator(configuration).credentialtypeFetchLanguage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialtypeFetchLogo(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialType>> {
            const localVarAxiosArgs = await CredentialtypeApiAxiosParamCreator(configuration).credentialtypeFetchLogo(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialtypeList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await CredentialtypeApiAxiosParamCreator(configuration).credentialtypeList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialtypeRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialType>> {
            const localVarAxiosArgs = await CredentialtypeApiAxiosParamCreator(configuration).credentialtypeRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CredentialtypeApi - factory interface
 * @export
 */
export const CredentialtypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this credential type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialtypeFetchLanguage(id: number, options?: any): AxiosPromise<CredentialType> {
            return CredentialtypeApiFp(configuration).credentialtypeFetchLanguage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialtypeFetchLogo(id: number, options?: any): AxiosPromise<CredentialType> {
            return CredentialtypeApiFp(configuration).credentialtypeFetchLogo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialtypeList(options?: any): AxiosPromise<InlineResponse2001> {
            return CredentialtypeApiFp(configuration).credentialtypeList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this credential type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialtypeRead(id: number, options?: any): AxiosPromise<CredentialType> {
            return CredentialtypeApiFp(configuration).credentialtypeRead(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialtypeApi - object-oriented interface
 * @export
 * @class CredentialtypeApi
 * @extends {BaseAPI}
 */
export class CredentialtypeApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this credential type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialtypeApi
     */
    public credentialtypeFetchLanguage(id: number, options?: any) {
        return CredentialtypeApiFp(this.configuration).credentialtypeFetchLanguage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this credential type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialtypeApi
     */
    public credentialtypeFetchLogo(id: number, options?: any) {
        return CredentialtypeApiFp(this.configuration).credentialtypeFetchLogo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialtypeApi
     */
    public credentialtypeList(options?: any) {
        return CredentialtypeApiFp(this.configuration).credentialtypeList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this credential type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialtypeApi
     */
    public credentialtypeRead(id: number, options?: any) {
        return CredentialtypeApiFp(this.configuration).credentialtypeRead(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * FeedbackApi - axios parameter creator
 * @export
 */
export const FeedbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [fromName] Sender name
         * @param {string} [fromEmail] Sender email address
         * @param {string} [comments] Comments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackCreate: async (fromName?: string, fromEmail?: string, comments?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/feedback`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


            if (fromName !== undefined) { 
                localVarFormParams.set('from_name', fromName as any);
            }
    
            if (fromEmail !== undefined) { 
                localVarFormParams.set('from_email', fromEmail as any);
            }
    
            if (comments !== undefined) { 
                localVarFormParams.set('comments', comments as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedbackApi - functional programming interface
 * @export
 */
export const FeedbackApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [fromName] Sender name
         * @param {string} [fromEmail] Sender email address
         * @param {string} [comments] Comments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedbackCreate(fromName?: string, fromEmail?: string, comments?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FeedbackApiAxiosParamCreator(configuration).feedbackCreate(fromName, fromEmail, comments, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FeedbackApi - factory interface
 * @export
 */
export const FeedbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [fromName] Sender name
         * @param {string} [fromEmail] Sender email address
         * @param {string} [comments] Comments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackCreate(fromName?: string, fromEmail?: string, comments?: string, options?: any): AxiosPromise<void> {
            return FeedbackApiFp(configuration).feedbackCreate(fromName, fromEmail, comments, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedbackApi - object-oriented interface
 * @export
 * @class FeedbackApi
 * @extends {BaseAPI}
 */
export class FeedbackApi extends BaseAPI {
    /**
     * 
     * @param {string} [fromName] Sender name
     * @param {string} [fromEmail] Sender email address
     * @param {string} [comments] Comments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public feedbackCreate(fromName?: string, fromEmail?: string, comments?: string, options?: any) {
        return FeedbackApiFp(this.configuration).feedbackCreate(fromName, fromEmail, comments, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IssuerApi - axios parameter creator
 * @export
 */
export const IssuerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this issuer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerFetchLogo: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling issuerFetchLogo.');
            }
            const localVarPath = `/issuer/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/issuer`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this issuer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerListCredentialTypes: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling issuerListCredentialTypes.');
            }
            const localVarPath = `/issuer/{id}/credentialtype`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this issuer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling issuerRead.');
            }
            const localVarPath = `/issuer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssuerApi - functional programming interface
 * @export
 */
export const IssuerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this issuer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuerFetchLogo(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issuer>> {
            const localVarAxiosArgs = await IssuerApiAxiosParamCreator(configuration).issuerFetchLogo(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuerList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await IssuerApiAxiosParamCreator(configuration).issuerList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this issuer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuerListCredentialTypes(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CredentialType>>> {
            const localVarAxiosArgs = await IssuerApiAxiosParamCreator(configuration).issuerListCredentialTypes(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this issuer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuerRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issuer>> {
            const localVarAxiosArgs = await IssuerApiAxiosParamCreator(configuration).issuerRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IssuerApi - factory interface
 * @export
 */
export const IssuerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this issuer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerFetchLogo(id: number, options?: any): AxiosPromise<Issuer> {
            return IssuerApiFp(configuration).issuerFetchLogo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerList(options?: any): AxiosPromise<InlineResponse2002> {
            return IssuerApiFp(configuration).issuerList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this issuer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerListCredentialTypes(id: number, options?: any): AxiosPromise<Array<CredentialType>> {
            return IssuerApiFp(configuration).issuerListCredentialTypes(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this issuer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerRead(id: number, options?: any): AxiosPromise<Issuer> {
            return IssuerApiFp(configuration).issuerRead(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IssuerApi - object-oriented interface
 * @export
 * @class IssuerApi
 * @extends {BaseAPI}
 */
export class IssuerApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this issuer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuerApi
     */
    public issuerFetchLogo(id: number, options?: any) {
        return IssuerApiFp(this.configuration).issuerFetchLogo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuerApi
     */
    public issuerList(options?: any) {
        return IssuerApiFp(this.configuration).issuerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this issuer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuerApi
     */
    public issuerListCredentialTypes(id: number, options?: any) {
        return IssuerApiFp(this.configuration).issuerListCredentialTypes(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this issuer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuerApi
     */
    public issuerRead(id: number, options?: any) {
        return IssuerApiFp(this.configuration).issuerRead(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * QuickloadApi - axios parameter creator
 * @export
 */
export const QuickloadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * quick load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2Quickload: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/quickload`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuickloadApi - functional programming interface
 * @export
 */
export const QuickloadApiFp = function(configuration?: Configuration) {
    return {
        /**
         * quick load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2Quickload(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await QuickloadApiAxiosParamCreator(configuration).apiV2Quickload(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QuickloadApi - factory interface
 * @export
 */
export const QuickloadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * quick load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2Quickload(options?: any): AxiosPromise<void> {
            return QuickloadApiFp(configuration).apiV2Quickload(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuickloadApi - object-oriented interface
 * @export
 * @class QuickloadApi
 * @extends {BaseAPI}
 */
export class QuickloadApi extends BaseAPI {
    /**
     * quick load
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickloadApi
     */
    public apiV2Quickload(options?: any) {
        return QuickloadApiFp(this.configuration).apiV2Quickload(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [version] 
         * @param {string} [originDid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaList: async (id?: number, name?: string, version?: string, originDid?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/schema`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (originDid !== undefined) {
                localVarQueryParameter['origin_did'] = originDid;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling schemaRead.');
            }
            const localVarPath = `/schema/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [version] 
         * @param {string} [originDid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaList(id?: number, name?: string, version?: string, originDid?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await SchemaApiAxiosParamCreator(configuration).schemaList(id, name, version, originDid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await SchemaApiAxiosParamCreator(configuration).schemaRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [version] 
         * @param {string} [originDid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaList(id?: number, name?: string, version?: string, originDid?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return SchemaApiFp(configuration).schemaList(id, name, version, originDid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRead(id: number, options?: any): AxiosPromise<Schema> {
            return SchemaApiFp(configuration).schemaRead(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * 
     * @param {number} [id] 
     * @param {string} [name] 
     * @param {string} [version] 
     * @param {string} [originDid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaList(id?: number, name?: string, version?: string, originDid?: string, options?: any) {
        return SchemaApiFp(this.configuration).schemaList(id, name, version, originDid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRead(id: number, options?: any) {
        return SchemaApiFp(this.configuration).schemaRead(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return autocomplete results for a query string
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [q] Query string
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAutocompleteList: async (ordering?: string, q?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/autocomplete`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }

            if (latest !== undefined) {
                localVarQueryParameter['latest'] = latest;
            }

            if (revoked !== undefined) {
                localVarQueryParameter['revoked'] = revoked;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return autocomplete results for a query string
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAutocompleteRead: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling searchAutocompleteRead.');
            }
            const localVarPath = `/search/autocomplete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * We want facet_counts from the less-restricted queryset
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialFacets: async (ordering?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/credential/facets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide credential search via Solr with both faceted (/facets) and unfaceted results
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {number} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialList: async (ordering?: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: number, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/credential`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }

            if (latest !== undefined) {
                localVarQueryParameter['latest'] = latest;
            }

            if (revoked !== undefined) {
                localVarQueryParameter['revoked'] = revoked;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (credentialTypeId !== undefined) {
                localVarQueryParameter['credential_type_id'] = credentialTypeId;
            }

            if (topicCredentialTypeId !== undefined) {
                localVarQueryParameter['topic_credential_type_id'] = topicCredentialTypeId;
            }

            if (issuerId !== undefined) {
                localVarQueryParameter['issuer_id'] = issuerId;
            }

            if (topicId !== undefined) {
                localVarQueryParameter['topic_id'] = topicId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide credential search via Solr with both faceted (/facets) and unfaceted results
         * @param {string} id 
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {string} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialRead: async (id: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling searchCredentialRead.');
            }
            const localVarPath = `/search/credential/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }

            if (latest !== undefined) {
                localVarQueryParameter['latest'] = latest;
            }

            if (revoked !== undefined) {
                localVarQueryParameter['revoked'] = revoked;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (credentialTypeId !== undefined) {
                localVarQueryParameter['credential_type_id'] = credentialTypeId;
            }

            if (topicCredentialTypeId !== undefined) {
                localVarQueryParameter['topic_credential_type_id'] = topicCredentialTypeId;
            }

            if (issuerId !== undefined) {
                localVarQueryParameter['issuer_id'] = issuerId;
            }

            if (topicId !== undefined) {
                localVarQueryParameter['topic_id'] = topicId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * We want facet_counts from the less-restricted queryset
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialTopicFacets: async (ordering?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/credential/topic/facets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {string} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialTopicList: async (ordering?: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/credential/topic`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }

            if (latest !== undefined) {
                localVarQueryParameter['latest'] = latest;
            }

            if (revoked !== undefined) {
                localVarQueryParameter['revoked'] = revoked;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (credentialTypeId !== undefined) {
                localVarQueryParameter['credential_type_id'] = credentialTypeId;
            }

            if (topicCredentialTypeId !== undefined) {
                localVarQueryParameter['topic_credential_type_id'] = topicCredentialTypeId;
            }

            if (issuerId !== undefined) {
                localVarQueryParameter['issuer_id'] = issuerId;
            }

            if (topicId !== undefined) {
                localVarQueryParameter['topic_id'] = topicId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {string} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialTopicRead: async (id: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling searchCredentialTopicRead.');
            }
            const localVarPath = `/search/credential/topic/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }

            if (latest !== undefined) {
                localVarQueryParameter['latest'] = latest;
            }

            if (revoked !== undefined) {
                localVarQueryParameter['revoked'] = revoked;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (credentialTypeId !== undefined) {
                localVarQueryParameter['credential_type_id'] = credentialTypeId;
            }

            if (topicCredentialTypeId !== undefined) {
                localVarQueryParameter['topic_credential_type_id'] = topicCredentialTypeId;
            }

            if (issuerId !== undefined) {
                localVarQueryParameter['issuer_id'] = issuerId;
            }

            if (topicId !== undefined) {
                localVarQueryParameter['topic_id'] = topicId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return autocomplete results for a query string
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [q] Query string
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAutocompleteList(ordering?: string, q?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).searchAutocompleteList(ordering, q, inactive, latest, revoked, category, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return autocomplete results for a query string
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAutocompleteRead(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialAutocomplete>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).searchAutocompleteRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * We want facet_counts from the less-restricted queryset
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCredentialFacets(ordering?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).searchCredentialFacets(ordering, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provide credential search via Solr with both faceted (/facets) and unfaceted results
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {number} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCredentialList(ordering?: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: number, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).searchCredentialList(ordering, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provide credential search via Solr with both faceted (/facets) and unfaceted results
         * @param {string} id 
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {string} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCredentialRead(id: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialSearch>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).searchCredentialRead(id, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * We want facet_counts from the less-restricted queryset
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCredentialTopicFacets(ordering?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).searchCredentialTopicFacets(ordering, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {string} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCredentialTopicList(ordering?: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).searchCredentialTopicList(ordering, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {string} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCredentialTopicRead(id: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialTopicSearch>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).searchCredentialTopicRead(id, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Return autocomplete results for a query string
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [q] Query string
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAutocompleteList(ordering?: string, q?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return SearchApiFp(configuration).searchAutocompleteList(ordering, q, inactive, latest, revoked, category, options).then((request) => request(axios, basePath));
        },
        /**
         * Return autocomplete results for a query string
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAutocompleteRead(id: string, options?: any): AxiosPromise<CredentialAutocomplete> {
            return SearchApiFp(configuration).searchAutocompleteRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * We want facet_counts from the less-restricted queryset
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialFacets(ordering?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return SearchApiFp(configuration).searchCredentialFacets(ordering, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide credential search via Solr with both faceted (/facets) and unfaceted results
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {number} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialList(ordering?: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: number, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return SearchApiFp(configuration).searchCredentialList(ordering, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide credential search via Solr with both faceted (/facets) and unfaceted results
         * @param {string} id 
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {string} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialRead(id: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any): AxiosPromise<CredentialSearch> {
            return SearchApiFp(configuration).searchCredentialRead(id, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options).then((request) => request(axios, basePath));
        },
        /**
         * We want facet_counts from the less-restricted queryset
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialTopicFacets(ordering?: string, options?: any): AxiosPromise<InlineResponse2006> {
            return SearchApiFp(configuration).searchCredentialTopicFacets(ordering, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {string} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialTopicList(ordering?: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any): AxiosPromise<InlineResponse2006> {
            return SearchApiFp(configuration).searchCredentialTopicList(ordering, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] Filter credentials by related name or topic source ID
         * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
         * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
         * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
         * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
         * @param {string} [credentialTypeId] Filter by Credential Type ID
         * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
         * @param {string} [issuerId] Filter by Issuer ID
         * @param {string} [topicId] Filter by Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCredentialTopicRead(id: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any): AxiosPromise<CredentialTopicSearch> {
            return SearchApiFp(configuration).searchCredentialTopicRead(id, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Return autocomplete results for a query string
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [q] Query string
     * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
     * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
     * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
     * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchAutocompleteList(ordering?: string, q?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, options?: any) {
        return SearchApiFp(this.configuration).searchAutocompleteList(ordering, q, inactive, latest, revoked, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return autocomplete results for a query string
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchAutocompleteRead(id: string, options?: any) {
        return SearchApiFp(this.configuration).searchAutocompleteRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * We want facet_counts from the less-restricted queryset
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCredentialFacets(ordering?: string, options?: any) {
        return SearchApiFp(this.configuration).searchCredentialFacets(ordering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide credential search via Solr with both faceted (/facets) and unfaceted results
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [name] Filter credentials by related name or topic source ID
     * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
     * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
     * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
     * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
     * @param {number} [credentialTypeId] Filter by Credential Type ID
     * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
     * @param {string} [issuerId] Filter by Issuer ID
     * @param {string} [topicId] Filter by Topic ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCredentialList(ordering?: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: number, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any) {
        return SearchApiFp(this.configuration).searchCredentialList(ordering, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide credential search via Solr with both faceted (/facets) and unfaceted results
     * @param {string} id 
     * @param {string} [name] Filter credentials by related name or topic source ID
     * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
     * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
     * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
     * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
     * @param {string} [credentialTypeId] Filter by Credential Type ID
     * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
     * @param {string} [issuerId] Filter by Issuer ID
     * @param {string} [topicId] Filter by Topic ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCredentialRead(id: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any) {
        return SearchApiFp(this.configuration).searchCredentialRead(id, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * We want facet_counts from the less-restricted queryset
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCredentialTopicFacets(ordering?: string, options?: any) {
        return SearchApiFp(this.configuration).searchCredentialTopicFacets(ordering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [name] Filter credentials by related name or topic source ID
     * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
     * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
     * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
     * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
     * @param {string} [credentialTypeId] Filter by Credential Type ID
     * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
     * @param {string} [issuerId] Filter by Issuer ID
     * @param {string} [topicId] Filter by Topic ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCredentialTopicList(ordering?: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any) {
        return SearchApiFp(this.configuration).searchCredentialTopicList(ordering, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [name] Filter credentials by related name or topic source ID
     * @param {'any' | 'false' | 'true'} [inactive] Show inactive credentials
     * @param {'any' | 'false' | 'true'} [latest] Show only latest credentials
     * @param {'any' | 'false' | 'true'} [revoked] Show revoked credentials
     * @param {string} [category] Filter by credential category. The category name and value should be joined by \&#39;::\&#39;
     * @param {string} [credentialTypeId] Filter by Credential Type ID
     * @param {string} [topicCredentialTypeId] Filter by any Credential Type ID owned by the Topic
     * @param {string} [issuerId] Filter by Issuer ID
     * @param {string} [topicId] Filter by Topic ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCredentialTopicRead(id: string, name?: string, inactive?: 'any' | 'false' | 'true', latest?: 'any' | 'false' | 'true', revoked?: 'any' | 'false' | 'true', category?: string, credentialTypeId?: string, topicCredentialTypeId?: string, issuerId?: string, topicId?: string, options?: any) {
        return SearchApiFp(this.configuration).searchCredentialTopicRead(id, name, inactive, latest, revoked, category, credentialTypeId, topicCredentialTypeId, issuerId, topicId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * quick load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2Status: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * quick load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2StatusReset: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/reset`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * quick load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2Status(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StatusApiAxiosParamCreator(configuration).apiV2Status(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * quick load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2StatusReset(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StatusApiAxiosParamCreator(configuration).apiV2StatusReset(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * quick load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2Status(options?: any): AxiosPromise<void> {
            return StatusApiFp(configuration).apiV2Status(options).then((request) => request(axios, basePath));
        },
        /**
         * quick load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2StatusReset(options?: any): AxiosPromise<void> {
            return StatusApiFp(configuration).apiV2StatusReset(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * quick load
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public apiV2Status(options?: any) {
        return StatusApiFp(this.configuration).apiV2Status(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * quick load
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public apiV2StatusReset(options?: any) {
        return StatusApiFp(this.configuration).apiV2StatusReset(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TopicApi - axios parameter creator
 * @export
 */
export const TopicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicCredentialListActiveCredentials: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling topicCredentialListActiveCredentials.');
            }
            const localVarPath = `/topic/{id}/credential/active`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicCredentialListHistoricalCredentials: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling topicCredentialListHistoricalCredentials.');
            }
            const localVarPath = `/topic/{id}/credential/historical`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sourceId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicIdentRetrieveByTypeFormatted: async (sourceId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling topicIdentRetrieveByTypeFormatted.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling topicIdentRetrieveByTypeFormatted.');
            }
            const localVarPath = `/topic/ident/{type}/{source_id}/formatted`
                .replace(`{${"source_id"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/topic`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicListCredentialSets: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling topicListCredentialSets.');
            }
            const localVarPath = `/topic/{id}/credentialset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicListCredentials: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling topicListCredentials.');
            }
            const localVarPath = `/topic/{id}/credential`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling topicRead.');
            }
            const localVarPath = `/topic/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sourceId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRetrieveByType: async (sourceId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling topicRetrieveByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling topicRetrieveByType.');
            }
            const localVarPath = `/topic/ident/{type}/{source_id}`
                .replace(`{${"source_id"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRetrieveFormatted: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling topicRetrieveFormatted.');
            }
            const localVarPath = `/topic/{id}/formatted`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicApi - functional programming interface
 * @export
 */
export const TopicApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicCredentialListActiveCredentials(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExpandedCredential>>> {
            const localVarAxiosArgs = await TopicApiAxiosParamCreator(configuration).topicCredentialListActiveCredentials(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicCredentialListHistoricalCredentials(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExpandedCredential>>> {
            const localVarAxiosArgs = await TopicApiAxiosParamCreator(configuration).topicCredentialListHistoricalCredentials(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sourceId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicIdentRetrieveByTypeFormatted(sourceId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomTopic>> {
            const localVarAxiosArgs = await TopicApiAxiosParamCreator(configuration).topicIdentRetrieveByTypeFormatted(sourceId, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await TopicApiAxiosParamCreator(configuration).topicList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicListCredentialSets(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExpandedCredentialSet>>> {
            const localVarAxiosArgs = await TopicApiAxiosParamCreator(configuration).topicListCredentialSets(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicListCredentials(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExpandedCredential>>> {
            const localVarAxiosArgs = await TopicApiAxiosParamCreator(configuration).topicListCredentials(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await TopicApiAxiosParamCreator(configuration).topicRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sourceId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicRetrieveByType(sourceId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await TopicApiAxiosParamCreator(configuration).topicRetrieveByType(sourceId, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicRetrieveFormatted(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await TopicApiAxiosParamCreator(configuration).topicRetrieveFormatted(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TopicApi - factory interface
 * @export
 */
export const TopicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicCredentialListActiveCredentials(id: number, options?: any): AxiosPromise<Array<ExpandedCredential>> {
            return TopicApiFp(configuration).topicCredentialListActiveCredentials(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicCredentialListHistoricalCredentials(id: number, options?: any): AxiosPromise<Array<ExpandedCredential>> {
            return TopicApiFp(configuration).topicCredentialListHistoricalCredentials(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sourceId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicIdentRetrieveByTypeFormatted(sourceId: string, type: string, options?: any): AxiosPromise<CustomTopic> {
            return TopicApiFp(configuration).topicIdentRetrieveByTypeFormatted(sourceId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicList(options?: any): AxiosPromise<InlineResponse2007> {
            return TopicApiFp(configuration).topicList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicListCredentialSets(id: number, options?: any): AxiosPromise<Array<ExpandedCredentialSet>> {
            return TopicApiFp(configuration).topicListCredentialSets(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicListCredentials(id: number, options?: any): AxiosPromise<Array<ExpandedCredential>> {
            return TopicApiFp(configuration).topicListCredentials(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRead(id: number, options?: any): AxiosPromise<Topic> {
            return TopicApiFp(configuration).topicRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sourceId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRetrieveByType(sourceId: string, type: string, options?: any): AxiosPromise<Topic> {
            return TopicApiFp(configuration).topicRetrieveByType(sourceId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRetrieveFormatted(id: number, options?: any): AxiosPromise<Topic> {
            return TopicApiFp(configuration).topicRetrieveFormatted(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TopicApi - object-oriented interface
 * @export
 * @class TopicApi
 * @extends {BaseAPI}
 */
export class TopicApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this topic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicCredentialListActiveCredentials(id: number, options?: any) {
        return TopicApiFp(this.configuration).topicCredentialListActiveCredentials(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this topic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicCredentialListHistoricalCredentials(id: number, options?: any) {
        return TopicApiFp(this.configuration).topicCredentialListHistoricalCredentials(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sourceId 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicIdentRetrieveByTypeFormatted(sourceId: string, type: string, options?: any) {
        return TopicApiFp(this.configuration).topicIdentRetrieveByTypeFormatted(sourceId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicList(options?: any) {
        return TopicApiFp(this.configuration).topicList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this topic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicListCredentialSets(id: number, options?: any) {
        return TopicApiFp(this.configuration).topicListCredentialSets(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this topic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicListCredentials(id: number, options?: any) {
        return TopicApiFp(this.configuration).topicListCredentials(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this topic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicRead(id: number, options?: any) {
        return TopicApiFp(this.configuration).topicRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sourceId 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicRetrieveByType(sourceId: string, type: string, options?: any) {
        return TopicApiFp(this.configuration).topicRetrieveByType(sourceId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this topic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicRetrieveFormatted(id: number, options?: any) {
        return TopicApiFp(this.configuration).topicRetrieveFormatted(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TopicRelationshipApi - axios parameter creator
 * @export
 */
export const TopicRelationshipApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRelationshipList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/topic_relationship`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic relationship.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRelationshipListRelatedFromRelations: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling topicRelationshipListRelatedFromRelations.');
            }
            const localVarPath = `/topic_relationship/{id}/related_from_relations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic relationship.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRelationshipListRelatedToRelations: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling topicRelationshipListRelatedToRelations.');
            }
            const localVarPath = `/topic_relationship/{id}/related_to_relations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic relationship.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRelationshipRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling topicRelationshipRead.');
            }
            const localVarPath = `/topic_relationship/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicRelationshipApi - functional programming interface
 * @export
 */
export const TopicRelationshipApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicRelationshipList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await TopicRelationshipApiAxiosParamCreator(configuration).topicRelationshipList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic relationship.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicRelationshipListRelatedFromRelations(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicRelationship>> {
            const localVarAxiosArgs = await TopicRelationshipApiAxiosParamCreator(configuration).topicRelationshipListRelatedFromRelations(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic relationship.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicRelationshipListRelatedToRelations(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicRelationship>> {
            const localVarAxiosArgs = await TopicRelationshipApiAxiosParamCreator(configuration).topicRelationshipListRelatedToRelations(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic relationship.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicRelationshipRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicRelationship>> {
            const localVarAxiosArgs = await TopicRelationshipApiAxiosParamCreator(configuration).topicRelationshipRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TopicRelationshipApi - factory interface
 * @export
 */
export const TopicRelationshipApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRelationshipList(options?: any): AxiosPromise<InlineResponse2008> {
            return TopicRelationshipApiFp(configuration).topicRelationshipList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic relationship.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRelationshipListRelatedFromRelations(id: number, options?: any): AxiosPromise<TopicRelationship> {
            return TopicRelationshipApiFp(configuration).topicRelationshipListRelatedFromRelations(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic relationship.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRelationshipListRelatedToRelations(id: number, options?: any): AxiosPromise<TopicRelationship> {
            return TopicRelationshipApiFp(configuration).topicRelationshipListRelatedToRelations(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this topic relationship.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRelationshipRead(id: number, options?: any): AxiosPromise<TopicRelationship> {
            return TopicRelationshipApiFp(configuration).topicRelationshipRead(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TopicRelationshipApi - object-oriented interface
 * @export
 * @class TopicRelationshipApi
 * @extends {BaseAPI}
 */
export class TopicRelationshipApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicRelationshipApi
     */
    public topicRelationshipList(options?: any) {
        return TopicRelationshipApiFp(this.configuration).topicRelationshipList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this topic relationship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicRelationshipApi
     */
    public topicRelationshipListRelatedFromRelations(id: number, options?: any) {
        return TopicRelationshipApiFp(this.configuration).topicRelationshipListRelatedFromRelations(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this topic relationship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicRelationshipApi
     */
    public topicRelationshipListRelatedToRelations(id: number, options?: any) {
        return TopicRelationshipApiFp(this.configuration).topicRelationshipListRelatedToRelations(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this topic relationship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicRelationshipApi
     */
    public topicRelationshipRead(id: number, options?: any) {
        return TopicRelationshipApiFp(this.configuration).topicRelationshipRead(id, options).then((request) => request(this.axios, this.basePath));
    }

}


